# Система прогнозирования нагрузки по модальностям

## Обзор
Этот проект представляет собой комплексный пайплайн для прогнозирования ежедневной нагрузки (количества исследований) на различные модальности (РГ, ММГ, КТ, МРТ и т.д.). 
Пайплайн состоит из трех основных этапов: предобработка данных, обучение моделей и генерация прогноза.

## Структура проекта
```plaintext
my_master_project/
├── data/ # Исходные и обработанные данные
│ ├── yandmast_obr2.csv # Сырые данные (скачиваются автоматически)
│ └── service_time_series.pkl # Обработанные временные ряды
├── models/ # Сохраненные обученные модели
│ ├── РГ_prophet.pkl
│ ├── РГ_xgboost.pkl
│ ├── Денс_spike_model.pkl
│ └── ... # и т.д. для каждой модальности
├── results/ # Результаты: метрики, прогнозы на тесте и на будущее
│ └── forecasting_results.xlsx
├── config.py # Глобальные настройки и константы
├── data_loader.py # Загрузка сырых данных
├── data_preprocessor.py # Создание временных рядов
├── model_trainer.py # Обучение моделей и расчет метрики
├── predictor.py # Генерация прогнозов на новые даты
└── run_pipeline.py # Главный скрипт для запуска всего пайплайна
```

## Установка и запуск
1.  **Клонируйте репозиторий и создайте виртуальное окружение:**
    ```bash
    git clone https://github.com/prokhorovpe/Master_projects.git
    cd Master_projects  # Или cd my_master_project, если вы переименовали папку локально
    python -m venv venv
    # Активируйте окружение (для Windows):
    venv\Scripts\activate
    # (для Linux/Mac):
    # source venv/bin/activate
    ```

2.  **Установите зависимости:**
    ```bash
    pip install -r requirements.txt
    pip install gdown  # Для скачивания данных
    ```

3.  **Запустите пайплайн:**
    ```bash
    python run_pipeline.py
    ```
    Скрипт автоматически:
    *   Скачает исходные данные (если их нет).
    *   Предобработает их и создаст временные ряды.
    *   Обучит модели для каждой модальности.
    *   Сгенерирует прогноз на заданный период (на N дней вперед от `END_DATE`).

## Ключевые особенности и сложные моменты для поддержки

### 1. Две стратегии моделирования
Проект использует **два разных типа моделей** в зависимости от частоты данных:
*   **Гибридная модель (`Prophet + XGBoost`)** для высокочастотных модальностей (`РГ`, `ММГ`).
    *   `Prophet` моделирует основной тренд и сезонность.
    *   `XGBoost` обучается на остатках (разнице между реальными данными и прогнозом Prophet) и использует календарные признаки.
*   **Модель детекции всплесков (`XGBoost Classifier + 2 XGBoost Regressor`)** для низкочастотных модальностей (`Денс`, `ФЛГ`, `КТ`, `МРТ`).
    *   Сначала `Classifier` предсказывает, будет ли в день "всплеск" (аномально высокое значение).
    *   Затем один из двух `Regressor` (для нормальных дней или для всплесков) делает финальный прогноз.

### 2. Генерация доверительных интервалов
Интервалы генерируются адаптивно, но с использованием разных стратегий для двух типов моделей:

*   Для Prophet + XGBoost (модальности РГ, ММГ):
На этапе тестирования (в model_trainer.py) интервалы рассчитываются на основе квантилей ошибок гибридной модели (Prophet + XGBoost) на тренировочных данных и применяются к прогнозу на тестовом периоде.
На этапе прогнозирования в будущее (в predictor.py) используется внутренняя неопределенность модели Prophet. Верхняя граница интервала рассчитывается как зеркальное отражение нижней границы относительно точечного прогноза: yhat_upper = yhat + (yhat - yhat_lower). Это создает симметричный интервал, который адаптируется к текущей волатильности прогноза. Нижняя граница обрезается до нуля, а верхняя граница не имеет жестких ограничений, что позволяет модели предсказывать рост за пределы исторических максимумов. Это ключевое отличие от этапа тестирования и обеспечивает более честную оценку будущей неопределенности.
*   Для Spike Detection (модальности Денс, ФЛГ, КТ, МРТ):
Интервалы рассчитываются на основе типа дня (рабочий/выходной) и заранее сохраненных квантилей ошибок и физических максимумов. Ключевой момент: В predictor.py для этой модели не пересчитываются статистики, а загружаются из сохраненного артефакта (*_spike_model.pkl). Это критически важно для обеспечения полной согласованности между этапами обучения и прогнозирования.

### 3. Календарные признаки
Функция `add_calendar_features` в `model_trainer.py` создает более 20 признаков. Ее **абсолютно необходимо использовать одинаково** на всех этапах (обучение, тест, прогноз). Любое изменение в этой функции потребует **полного переобучения всех моделей**.

### 4. Постобработка прогнозов
Функция `final_postprocessing` применяет "физические" ограничения к прогнозу:
*   Для выходных и праздничных дней прогноз обрезается до исторического 95-го перцентиля.
*   Для дней, где Prophet предсказал почти ноль, прогноз обрезается до медианы низкой нагрузки.
Это предотвращает неадекватно высокие или низкие прогнозы.

### 5. Управление зависимостями
В `config.py` централизованно задаются все ключевые параметры:
*   Периоды обучения (`START_DATE`, `END_DATE`, `TEST_START_DATE`).
*   Период прогноза (`FORECAST_START_DATE`, `FORECAST_PERIOD_DAYS`).
*   Список праздников (`RU_HOLIDAYS`) — **требует ежегодного обновления вручную**.
*   Классификация модальностей (`HIGH_FREQUENCY_MODALITIES`, `SPECIALIZED_MODALITIES`).

## Выходные данные
Основной результат работы пайплайна — файл `results/forecasting_results.xlsx`. Он содержит:
*   Лист `Сводная_таблица`: Метрики качества (MAPE, R2, RMSE, MAE) на тестовом периоде для каждой модальности.
*   Листы `Тест_<Модальность>`: Детальные прогнозы и доверительные интервалы на тестовом периоде.
*   Листы `Будущее_<Модальность>`: Финальный прогноз и доверительные интервалы на заданный период в будущем.

## Обновление данных
Для обновления прогноза на новые данные:
1.  Поместите новый файл данных в `data/yandmast_obr2.csv` (или измените `RAW_DATA_PATH` в `config.py`).
2.  Запустите `python run_pipeline.py`.
Система автоматически перестроит временные ряды, переобучит модели и сгенерирует новый прогноз.